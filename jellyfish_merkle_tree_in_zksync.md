# Introduction

`Jellyfish Merkle Tree`(JMT) is the sparse merkle tree solution adopted by `zksync-era`. 

It features a `tractable radix representation` for sparse merkle tree and `version-based key` that reduces compaction for LSM-tree based key-value storage.


# Tractable Radix Representation

While a full tree with h-bit keys of size $2^h$ is an intractable representation when h is a large value, JMT transforms it into a tractable one for a sparse merkle tree.

Let's go through the process by an example.

A naive merkle tree may look like this:

```mermaid
graph TB
    n0(( )) --0--> n1(( ))
    n0(( )) --1--> n2(( ))
    n1 --0--> n3(( ))
    n1 --1--> n4(( ))
    n2 --0--> n5(( ))
    n2 --1--> n6(( ))
    n3 --0--> n7(( ))
    n3 --1--> n8(( ))
    n4 --0--> n9(( ))
    n4 --1--> n10(( ))
    n5 --0--> n11(( ))
    n5 --1--> n12(( ))
    n6 --0--> n13(( ))
    n6 --1--> n14(( ))
    n7 --0--> n15(( ))
    n7 --1--> n16(( ))
    n8 --0--> n17(( ))
    n8 --1--> n18(( ))
    n9 --0--> n19(( A ))
    n9 --1--> n20(( ))
    n10 --0--> n21(( ))
    n10 --1--> n22(( ))
    n11 --0--> n23(( B ))
    n11 --1--> n24(( ))
    n12 --0--> n25(( ))
    n12 --1--> n26(( C ))
    n13 --0--> n27(( ))
    n13 --1--> n28(( ))
    n14 --0--> n29(( ))
    n14 --1--> n30(( ))
```

JMT first incorporates two optimizations:
1. Subtrees that consist entirely of empty nodes are replaced with a placeholder value, indicated with □.
2. Subtrees consisting of exactly one leaf are replaced with a single node.

After optimization 1 it looks like this:

```mermaid
graph TB
    n0(( )) --0--> n1(( ))
    n0(( )) --1--> n2(( ))
    n1 --0--> n3[ ]
    n1 --0--> n4(( ))
    n2 --0--> n5(( ))
    n2 --1--> n6[ ]
    
    n4 --0--> n9(( ))
    n4 --1--> n10[ ]
    n5 --0--> n11(( ))
    n5 --1--> n12(( ))
    
    
    n9 --0--> n19(( A ))
    n9 --1--> n20[ ]
    
    n11 --0--> n23(( B ))
    n11 --1--> n24[ ]
    n12 --0--> n25[ ]
    n12 --1--> n26(( C ))
```

After optimization 2 it looks like this:

```mermaid
graph TB
    n0(( )) --0--> n1(( A ))
    n0(( )) --1--> n2(( ))
    
    n2 --0--> n5(( ))
    n2 --1--> n6[ ]
    
    
    n5 --0--> n11(( B ))
    n5 --1--> n12(( C ))
```

(Note that the full key of leaf nodes are also stored together with the node since it's no longer inferable from the path.)

As an update of a single leaf node can require all the nodes on the path to the root to be updated together, JMT further employs a radix merkle tree structure to reduce the I/O. A radix merkle tree with radix `r` is the compressed version of the corresponding merkle tree such that every $log_2 (r)$ levels of the original merkle tree are compressed into a single level where each node has maximum `r` children, though some children may not exist.

Most radix merkle trees choose `r=16`, so instead of bit by by, traversing downward consumes one nibble(4 bits) at a time.

Paired with the above optimizations, the original merkle tree finally looks like this:

```mermaid
graph TB
    n0(( )) --0x4--> n1(( A ))
    n0(( )) --0x8--> n2(( B ))
    n0(( )) --0xB--> n3(( C ))
```

# Version-based Key

Since nodes are stored in a key-value store, each node is associated with a unique key. JMT adopts a version-based node key
schema, by splicing `version` and `nibble path`, as:

```
version ‖ nibble path
```

where the node of this key is created at `version` and `nibble path` is the sequence of nibbles on the path from the root node to this node following the given key.

There are two advantages of the version-based node key over widely adopted hash-based node key:
1. Compared to a fixed-length hash-based node key, a JMT node key takes less space in a sparse merkle tree. For a JMT of 256-bit keys and 1 billion leaves, the average height is around 8 nibbles. The average size of all the node keys is about 12 bytes, significantly smaller than 32 bytes of a 256-bit hash key.
2.  The versioned JMT could remarkably reduce compactions to zero, thereby achieving the optimal write amplification as one. In LevelDB or RocksDB, all the data is stored as key-value pairs and all keys are sorted by a predefined order, usually lexicographic or reverse-lexicographic order. If a hash key is adopted, each insertion will insert a new key-value pair at a random position within the current key spectrum. But given the JMT node key schema, we could insert the new nodes generated by each version sequentially to append to the current key set in storage according to the lexicographic order because our key schema ensures keys of a high version are always lexicographically greater than that at a lower version. In this case, compaction is no longer necessary as the keys inserted are already ordered. Experiment shows this schema saves IOPS and disk bandwidth by more than 90% in contrast to hash-based node keys.

# Implementation

(in progress)

# References
1. https://developers.diem.com/papers/jellyfish-merkle-tree/2021-01-14.pdf